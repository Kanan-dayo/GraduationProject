//==========================================================================================================================================================
//
// チャット用テキスト処理 [ chatText.cpp ]
// Author : KANAN NAGANAWA
//
//==========================================================================================================================================================
#include "chatText.h"
#include "renderer.h"
#include "manager.h"

//==========================================================================================================================================================
// マクロ定義
//==========================================================================================================================================================
#define CHARACTER_HEIGHT		(18)				// 文字の高さ
#define CHARACTER_WIDTH			(0)					// 文字の幅
#define CHARACTER_LINE_WEIGHT	(1)					// 文字の太さ
#define CHARACTER_FONTNAME		("ＭＳ ゴシック")	// 文字のフォント名

//==========================================================================================================================================================
// 静的メンバ変数
//==========================================================================================================================================================
LPD3DXFONT	CChatText::m_pFont					= NULL;			// フォント情報
char		CChatText::m_aStr[MAX_CHARACTER]	= {};			// 文字数

//==========================================================================================================================================================
// 初期化
//==========================================================================================================================================================
void CChatText::Init(void)
{
	// デバッグ表示用フォントを設定
	D3DXCreateFont(CManager::GetRenderer()->GetDevice(),	// デバイス
		CHARACTER_HEIGHT,		// 文字の高さ
		CHARACTER_WIDTH,		// 文字の幅
		CHARACTER_LINE_WEIGHT,	// 文字の太さ
		0,						// ミップマップレベルの数
		FALSE,					// 文字の斜体化
		SHIFTJIS_CHARSET,		// フォントの文字セット
		OUT_DEFAULT_PRECIS, 
		DEFAULT_QUALITY, 
		DEFAULT_PITCH, 
		CHARACTER_FONTNAME,		// 文字のフォント名
		&m_pFont);				// 格納先

	m_textColor = WhiteColor;

	// 文字列の初期化
	for (int nCnt = 0; nCnt < MAX_KEEPTEXT; nCnt++)
	{
		strcpy(m_cKeepText[nCnt], "");
	}
}

//==========================================================================================================================================================
// 終了
//==========================================================================================================================================================
void CChatText::Uninit(void)
{
	if (m_pFont != NULL)
	{
		m_pFont->Release();
		m_pFont = NULL;
	}
}

//==========================================================================================================================================================
// 表示
//==========================================================================================================================================================
void CChatText::Print(char* fmt, ...)
{
	va_list args;

	// これまでのすべての文字数を計算
	int nStrLength = (int)strlen(m_aStr);
	// 追加で表示する文字数を計算
	int nFmtLehgth = (int)strlen(fmt);
	int nCnt;
	char *pFmt;

	// 文字数が最大を超えた時
	if (nStrLength + nFmtLehgth > MAX_CHARACTER)
	{
		std::cout << "文字数越え" << std::endl;
		return;
	}

	// fmtの初期化
	va_start(args, fmt);

	for (pFmt = (char *)fmt, nCnt = 0; *pFmt != '\0'; pFmt++, nCnt++)
	{
		// fmtの型・文字数を決定する
		vsprintf(&m_aStr[nStrLength], fmt, args);
	}

	// argsを使えない状態にする
	va_end(args);
}

//==========================================================================================================================================================
// 描画
//==========================================================================================================================================================
void CChatText::Draw(void)
{
	RECT rect = { 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT };

	// テキスト描画
	m_pFont->DrawText(NULL, 
		&m_aStr[0],
		-1,
		&rect,
		DT_LEFT,
		m_textColor);

	// 連続して文字数計算をしないよう\0を置く
	m_aStr[0] = '\0';
}

